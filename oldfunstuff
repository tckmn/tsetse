{-# LANGUAGE TemplateHaskell #-}

module Templates where

import Control.Monad
import Data.Char
import Language.Haskell.TH

import Types

fn :: String -> Name -> PatQ
fn s = pure . VarP . mkName . (s++) . capitalize . nameBase
    where capitalize "" = ""
          capitalize (c:s) = toUpper c : s

makeGameFns :: Name -> DecsQ
makeGameFns t = do
    TyConI (DataD _ _ _ _ [RecC _ fields] _) <- reify t

    foldr1 (liftM2 (++)) [[d|

        $(fn "get" name) = GameIO $ \s g ->
            return (Just ($(pure $ VarE name) g), g)

        $(fn "set" name) = \n -> GameIO $ \s g ->
            return (Just $([|n|]), $(pure $ RecUpdE (VarE 'g) [(name, VarE 'n)]))

        $(fn "mod" name) = \f -> GameIO $ \s g ->
            let r = f $ $(pure $ VarE name) g in
            return (Just r, $(pure $ RecUpdE (VarE 'g) [(name, VarE 'r)]))

      |] | (name, _, _) <- fields]

makeStateFns :: Name -> DecsQ
makeStateFns t = do
    TyConI (DataD _ _ _ _ [ForallC _ _ (RecC _ fields)] _) <- reify t

    foldr1 (liftM2 (++)) [[d|

        $(fn "get" name) = GameIO $ \s g ->
            return (Just ($(pure $ VarE name) s), g)

      |] | (name, _, _) <- fields, nameBase name /= "game"]


===


newtype GameIO g a = GameIO { runGameIO :: ServerState -> g -> IO (Maybe a, g) }

instance Monad (GameIO g) where
    return x = GameIO $ \s g -> return (Just x, g)
    (GameIO h) >>= f = GameIO $ \s g -> do
        (a, g') <- h s g
        case a of
          Nothing -> return (Nothing, g')
          Just a -> let GameIO h' = f a in h' s g'

instance Applicative (GameIO g) where
    pure = return
    (<*>) = ap

instance Functor (GameIO g) where
    fmap = liftM


===


play :: MVar ServerState -> Client -> Text -> Text -> IO ()

-- requesting admin access
play state (Client cid conn) "a" pwd =
    modifyMVar_ state $ \s@ServerState{password,admins} -> do
        let good = pwd == password
        sendWS conn $ encodeAdmin good
        if good then withClientsUpdate s { admins = cid:admins } else return s

-- admin submitted a new wall
play state (Client cid conn) "w" walldata =
    modifyMVar_ state $ \s@ServerState{clients,wall,groups,strikes,startTime,duration} -> reqa s cid $ do
        -- jesus christ, what a line
        new <- sequence $ liftM2 zip (shuffle [0..15]) . pure <$> parseWall walldata
        -- tell everyone about it
        now <- timeMillis
        sequence_ $ broadcast clients . encodeWall now duration <$> new
        -- make sure to keep this in sync with ABC in netwall.js
        return s { wall      = fromMaybe wall               new
                 , groups    = fromMaybe groups    $ []  <$ new
                 , strikes   = fromMaybe strikes   $ 3   <$ new
                 , startTime = fromMaybe startTime $ now <$ new
                 }
    where parseWall s = let cells = filter (not . T.null) . map strip . T.splitOn "\n" $ chomp s
                         in cells <$ guard (length cells == 16)

-- admin cleared wall
play state (Client cid conn) "W" _ =
    modifyMVar_ state $ \s@ServerState{clients,wall,groups,strikes,startTime,duration} -> reqa s cid $ do
        broadcast clients "W"
        -- make sure to keep this in sync with DEF in netwall.js
        return s { wall      = []
                 , groups    = []
                 , strikes   = 3
                 , startTime = 0
                 }

-- (un)make someone an admin
-- ugly code duplication between this and the "P" case, but whatever
play state (Client cid conn) "A" req =
    modifyMVar_ state $ \s@ServerState{clients,admins} -> reqa s cid $ do
        let (action,target) = T.splitAt 1 req
            yes = action == "1"
        -- we won't bother checking if target is real because we trust admins
        broadcast (withCid target clients) $ encodeAdmin yes
        withClientsUpdate s { admins = [target | yes] ++ filter (/=target) admins }

-- (un)make someone a player
play state (Client cid conn) "P" req =
    modifyMVar_ state $ \s@ServerState{clients,players} -> reqa s cid $ do
        let (action,target) = T.splitAt 1 req
            yes = action == "1"
        -- we won't bother checking if target is real because we trust admins
        broadcast (withCid target clients) $ encodePlayer yes
        withClientsUpdate s { players = [target | yes] ++ filter (/=target) players }

-- player submitted a guess
play state (Client cid conn) "g" guess =
    modifyMVar_ state $ \s@ServerState{clients,groups} -> reqp s cid $ do
        now <- timeMillis
        fromMaybe (return s) (makeGuess s <$> parseGuess s now guess)
    where parseGuess s@ServerState{groups,strikes,startTime,duration} now guess = do
              guard $ strikes /= 0
              guard $ now - startTime < (fromIntegral duration)*1000
              xs <- sequence $ decimal <$> T.splitOn "/" guess
              guard $ all ($xs) [(==4) . length,
                                 liftM2 (==) id nub,
                                 all (liftM2 (&&) (between 0 15) (`notElem` groups))]
              return xs
          makeGuess s@ServerState{clients,groups,wall,strikes} guess =
              if sort guess `elem` (map sort . chunksOf 4 $ fst <$> wall)
                 then do
                     let groups' = groups ++ guess
                         groups'' = if length groups' == 12
                                       then groups' ++ filter (`notElem` groups') [0..15]
                                       else groups'
                     broadcast clients $ encodeGuess True groups''
                     return s { groups = groups'' }
                 else do
                     let strike = length groups == 8
                         strikes' = strikes - if strike then 1 else 0
                     broadcast clients $ encodeGuess False guess
                     when strike $ broadcast clients $ encodeStrikes strikes'
                     return s { strikes = strikes' }

-- timesync
play state (Client _ conn) "t" stamp = timeSync conn $ T.cons 't' stamp

play _ (Client _ conn) _ _ = logC conn "misbehaving client??"



encodeYN :: Char -> Bool -> Text
encodeYN ch yes = T.pack $ ch:(if yes then "1" else "0")
encodeAdmin :: Bool -> Text
encodeAdmin = encodeYN 'a'
encodePlayer :: Bool -> Text
encodePlayer = encodeYN 'p'
encodeWall :: Integer -> Int -> [(Int,Text)] -> Text
encodeWall st du = ('w' `T.cons`) . T.intercalate "\n" . w st . w du . map snd . sortOn fst
    where w x = (T.pack (show x):)
encodeGuess :: Bool -> [Int] -> Text
encodeGuess yes idxs = T.pack $ (if yes then 'g' else 'G'):intercalate "/" (show <$> idxs)
encodeStrikes :: Int -> Text
encodeStrikes = T.pack . ('s':) . show
encodeClients :: [Client] -> Map ClientId Text -> [ClientId] -> [ClientId] -> Text
encodeClients clients secrets players admins =
    ('c' `T.cons`) . T.intercalate "/" . map stringify . sortOn sortPred $ M.toList secrets
    where sortPred (cid,sec) = fromMaybe (length clients) $ findIndex ((==cid) . clientId) clients
          stringify (cid,sec) = T.concat [fmtCount . length . withCid cid $ clients,
                                          fmtYN "p" (cid `elem` players),
                                          fmtYN "a" (cid `elem` admins), " ",
                                          cid, " ",
                                          T.take 5 sec, " ", T.drop 5 sec]
          fmtCount n | n > 9 = "*"
                     | n > 0 = T.pack $ show n
                     | otherwise = " "
          fmtYN s True  = s
          fmtYN s False = " "
